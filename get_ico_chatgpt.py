#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Enhanced version with multi-sheet support and dynamic column selection

import time
import re
import requests
import pandas as pd
from typing import Optional, Dict, Any, List
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
import sys

# ====== Konfigur√°cia ======
DEFAULT_INPUT_XLSX = "test_120firiem.xlsx"  # predvolen√Ω vstupn√Ω s√∫bor
DEFAULT_COLUMN_NAME = "Firma"
DEFAULT_SHEET_NAME = None  # prv√Ω hark
INTERACTIVE_MODE = True

RPO_BASE = "https://api.statistics.sk/rpo/v1/search"
ONLY_ACTIVE = True

# Limity / v√Ωkon
MAX_WORKERS = 6                 # paraleliz√°cia (6 vl√°kien je bezpeƒçn√Ωch)
MAX_REQ_PER_MIN = 60            # cieƒæ: neprekroƒçi≈• ~60/min
REQUEST_TIMEOUT = 12            # s
RETRY_COUNT = 3
RETRY_SLEEP_BASE = 0.7          # s (exponenci√°lny backoff)
BATCH_SIZE = 60                 # d√°vkujeme ~60 a kr√°tko sp√≠me, aby sme dr≈æali tempo


# ====== Pomocn√© funkcie ======
def is_valid_ico(ico: str) -> bool:
    """
    Over√≠ SK IƒåO ‚Äì 8 ƒç√≠slic, kontroln√Ω s√∫ƒçet podƒæa v√°h 8..2 (mod 11).
    """
    if not re.fullmatch(r"\d{8}", ico):
        return False
    digits = [int(ch) for ch in ico]
    weights = [8, 7, 6, 5, 4, 3, 2]
    s = sum(d * w for d, w in zip(digits[:7], weights))
    mod = s % 11
    check = {0: 1, 1: 0}.get(mod, 11 - mod)
    return digits[7] == check


def normalize_ico(value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    digits = re.sub(r"\D+", "", value)
    if len(digits) == 8 and is_valid_ico(digits):
        return digits
    # ak m√° 8 ƒç√≠slic ale bez valid√°cie, st√°le vr√°time ‚Äî nie v≈°etky z√°znamy maj√∫ spr√°ve
    # naplnen√© metad√°ta, no IƒåO b√Ωva korektn√©
    return digits if len(digits) == 8 else None


def choose_best_record(records: List[Dict[str, Any]], query_name: str) -> Optional[Dict[str, Any]]:
    """
    Z v√Ωsledkov vyber najpravdepodobnej≈°iu zhodu:
    1) presn√° (casefold) zhoda v poli fullNames[].value
    2) prv√Ω z√°znam
    """
    q = query_name.strip().casefold()
    for rec in records:
        for fn in rec.get("fullNames", []) or []:
            name_val = (fn.get("value") or "").strip().casefold()
            if name_val == q:
                return rec
    return records[0] if records else None


def extract_ico_from_record(record: Dict[str, Any]) -> Optional[str]:
    """
    RPO odpoveƒè: ICO je v poli 'identifiers' (zvykn√∫ tam by≈• r√¥zne identifik√°tory).
    Budeme hƒæada≈• 8-miestne ƒç√≠slo. Ak je k dispoz√≠cii 'type' s hodnotou ICO, preferujeme ho.
    """
    for ident in record.get("identifiers", []) or []:
        type_val = (ident.get("type", {}).get("value") or "").casefold()
        val = normalize_ico(ident.get("value"))
        if type_val in {"ico", "iƒço", "ico_sk"} and val:
            return val

    # fallback: prv√© validn√© 8-miestne ƒç√≠slo v identifiers
    for ident in record.get("identifiers", []) or []:
        val = normalize_ico(ident.get("value"))
        if val:
            return val
    return None


def rpo_lookup_ico(company_name: str) -> Optional[str]:
    """
    Zavol√° RPO /search?fullName=...&onlyActive=true a vr√°ti IƒåO alebo None.
    """
    params = {
        "fullName": company_name,
        "onlyActive": str(ONLY_ACTIVE).lower(),
    }

    for attempt in range(1, RETRY_COUNT + 1):
        try:
            r = requests.get(RPO_BASE, params=params, timeout=REQUEST_TIMEOUT)
            if r.status_code == 200:
                data = r.json()
                records = (data or {}).get("results") or []
                if not records:
                    return None
                best = choose_best_record(records, company_name)
                return extract_ico_from_record(best) if best else None

            # 429/5xx: jemn√Ω backoff
            time.sleep(RETRY_SLEEP_BASE * attempt)
        except requests.RequestException:
            time.sleep(RETRY_SLEEP_BASE * attempt)

    return None


class RateLimiter:
    """
    Jednoduch√Ω limiter: max N po≈æiadaviek za 60 s (posuvn√© okno).
    """
    def __init__(self, max_per_min: int):
        self.max_per_min = max_per_min
        self.window_start = time.monotonic()
        self.count = 0

    def acquire(self):
        now = time.monotonic()
        elapsed = now - self.window_start
        if elapsed >= 60:
            self.window_start = now
            self.count = 0

        if self.count >= self.max_per_min:
            sleep_for = 60 - elapsed
            if sleep_for > 0:
                time.sleep(sleep_for)
            self.window_start = time.monotonic()
            self.count = 0

        self.count += 1


# ====== Excel handling ======
def list_excel_sheets(file_path: Path) -> List[str]:
    """
    Vr√°ti zoznam v≈°etk√Ωch harkov v Excel s√∫bore.
    """
    try:
        excel_file = pd.ExcelFile(file_path)
        return excel_file.sheet_names
    except Exception as e:
        print(f"Chyba pri ƒç√≠tan√≠ harkov z {file_path}: {e}")
        return []

def get_user_sheet_choice(sheets: List[str]) -> str:
    """
    Interakt√≠vny v√Ωber harku pou≈æ√≠vateƒæom.
    """
    if len(sheets) == 1:
        print(f"Excel obsahuje jeden hark: '{sheets[0]}'")
        return sheets[0]
    
    print(f"\nExcel s√∫bor obsahuje harky: {sheets}")
    while True:
        choice = input(f"Vyber hark (stlaƒç Enter pre '{sheets[0]}'): ").strip()
        if not choice:
            return sheets[0]
        if choice in sheets:
            return choice
        print(f"Neplatn√Ω hark '{choice}'. Dostupn√© harky: {sheets}")

def get_user_column_choice(df: pd.DataFrame, default: str = DEFAULT_COLUMN_NAME) -> str:
    """
    Interakt√≠vny v√Ωber stƒ∫pca pou≈æ√≠vateƒæom.
    """
    columns = df.columns.tolist()
    print(f"\nDostupn√© stƒ∫pce: {columns}")
    
    while True:
        choice = input(f"Zadaj n√°zov stƒ∫pca s firmami (Enter pre '{default}'): ").strip()
        if not choice:
            if default in columns:
                return default
            else:
                print(f"Predvolen√Ω stƒ∫pec '{default}' neexistuje. Vyber zo zoznamu.")
                continue
        if choice in columns:
            return choice
        print(f"Neplatn√Ω stƒ∫pec '{choice}'. Dostupn√© stƒ∫pce: {columns}")

def validate_column_data(df: pd.DataFrame, column: str) -> bool:
    """
    Validuje d√°ta v stƒ∫pci - kontroluje pr√°zdne hodnoty a typ.
    """
    if column not in df.columns:
        return False
    
    total_rows = len(df)
    non_null_rows = df[column].notna().sum()
    empty_rows = total_rows - non_null_rows
    
    if non_null_rows == 0:
        print(f"‚ö†Ô∏è  Stƒ∫pec '{column}' je √∫plne pr√°zdny!")
        return False
    
    if empty_rows > 0:
        print(f"‚ö†Ô∏è  Stƒ∫pec '{column}' obsahuje {empty_rows}/{total_rows} pr√°zdnych hodn√¥t.")
        choice = input("Pokraƒçova≈•? (y/n): ").strip().lower()
        if choice not in ['y', 'yes', 'a', 'ano', '']:
            return False
    
    print(f"‚úÖ Stƒ∫pec '{column}' obsahuje {non_null_rows} validn√Ωch z√°znamov.")
    return True

def get_user_input_file() -> Optional[Path]:
    """
    Interakt√≠vne z√≠skanie vstupn√©ho s√∫boru.
    """
    while True:
        src = input(f"Zadaj n√°zov zdrojov√©ho Excel s√∫boru (Enter pre '{DEFAULT_INPUT_XLSX}'): ").strip()
        if not src:
            src = DEFAULT_INPUT_XLSX
        
        src_path = Path(src)
        if not src_path.exists():
            print(f"S√∫bor '{src_path}' neexistuje. Skontroluj cestu/n√°zov.")
            continue
        
        if src_path.suffix.lower() != ".xlsx":
            print("Oƒçak√°vam .xlsx s√∫bor.")
            continue
            
        return src_path


def process_names(names: List[str]) -> List[Optional[str]]:
    """
    Spracuje men√° s paraleliz√°ciou a rate-limitom (~60/min).
    """
    results: List[Optional[str]] = [None] * len(names)
    limiter = RateLimiter(MAX_REQ_PER_MIN)

    def task(i: int, name: str) -> Optional[str]:
        limiter.acquire()
        return rpo_lookup_ico(name)

    for offset in range(0, len(names), BATCH_SIZE):
        idxs = list(range(offset, min(offset + BATCH_SIZE, len(names))))
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as pool:
            fut_map = {pool.submit(task, i, names[i]): i for i in idxs}
            for fut in as_completed(fut_map):
                i = fut_map[fut]
                try:
                    results[i] = fut.result()
                except Exception:
                    results[i] = None

        # kr√°tka pauza medzi d√°vkami (dr≈æ√≠me rytmus, ≈°etr√≠me API)
        time.sleep(1.0)

    return results


def main():
    print("üîç ICO Collector - Z√°kladn√° verzia")
    print("=" * 40)
    
    # 1. Z√≠skanie vstupn√©ho s√∫boru
    src_path = get_user_input_file()
    if not src_path:
        return
    
    # 2. V√Ωber harku
    sheets = list_excel_sheets(src_path)
    if not sheets:
        print("Nepodarilo sa naƒç√≠ta≈• harky z Excel s√∫boru.")
        return
    
    selected_sheet = get_user_sheet_choice(sheets)
    
    # 3. Naƒç√≠tanie vybran√©ho harku
    try:
        df = pd.read_excel(src_path, sheet_name=selected_sheet)
    except Exception as e:
        print(f"Chyba pri naƒç√≠tan√≠ harku '{selected_sheet}': {e}")
        return
    
    if df.empty:
        print(f"Hark '{selected_sheet}' je pr√°zdny.")
        return
    
    # 4. V√Ωber stƒ∫pca
    selected_column = get_user_column_choice(df, DEFAULT_COLUMN_NAME)
    
    # 5. Valid√°cia d√°t v stƒ∫pci
    if not validate_column_data(df, selected_column):
        print("Spracovanie preru≈°en√© kv√¥li probl√©mom s d√°tami.")
        return

    # 6. Pr√≠prava v√Ωstupn√Ωch s√∫borov
    output_xlsx = src_path.with_name(f"{src_path.stem}_s_ICO.xlsx")
    output_csv = src_path.with_name(f"{src_path.stem}_s_ICO.csv")

    # 7. Extrakcia a spracovanie d√°t
    names = df[selected_column].astype(str).fillna("").tolist()
    
    print(f"\nüìä Zaƒç√≠nam spracovanie {len(names)} firiem‚Ä¶")
    print(f"üìÅ Hark: '{selected_sheet}'")
    print(f"üìã Stƒ∫pec: '{selected_column}'")
    print(f"üíæ V√Ωstupy: {output_xlsx.name}, {output_csv.name}\n")
    
    icos = process_names(names)

    # 8. Ulo≈æenie v√Ωsledkov
    df["ICO"] = icos
    df.to_excel(output_xlsx, index=False)
    df.to_csv(output_csv, index=False, encoding="utf-8")

    # 9. ≈†tatistiky
    ok = sum(1 for x in icos if x)
    print(f"\n‚úÖ Hotovo: {ok}/{len(icos)} n√°jden√Ωch IƒåO")
    print(f"üìÅ V√Ωstupy: {output_xlsx.name}, {output_csv.name}")


if __name__ == "__main__":
    main()